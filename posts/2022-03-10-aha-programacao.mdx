---
title: Programa√ß√£o AHA
subtitle:
description:
hero_image: "/assets/uploads/cover/programacao_aha.png"
date: 2022-03-10 12:00:00
author: Allan Ramos
category: 'Programa√ß√£o'
series: ''
---

import EmbedVideo from '../src/components/EmbedVideo';

Esse artigo √© uma tradu√ß√£o do artigo original [AHA Programming](https://kentcdodds.com/blog/aha-programming) criado por [Kent C. Dodds](https://kentcdodds.com/).

# Veja minha talk: Programa√ß√£o AHA

<EmbedVideo
  url="https://www.youtube.com/embed/wuVy7rwkCfc"
  title="AHA Programming"
/>

# DRY

[DRY (um acr√¥nimo para "Don't Repeat Yourself", traduzindo "N√£o se repita")](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), √© um antigo princ√≠pio de software que a Wikipedia resume assim:

> Cada por√ß√£o de conhecimento em um sistema deve possuir uma representa√ß√£o √∫nica, de autoridade e livre de ambiguidades em todo o sistema.

Essa geralmente √© uma boa pr√°tica que eu adoto(embora de forma menos dogm√°tica do que a defini√ß√£o encoraja). O maior problema que tive com [duplica√ß√£o de c√≥digo](https://en.wikipedia.org/wiki/Duplicate_code)(aka copia/cola, basicamente a ant√≠tese do *`DRY`*) √© perceber que tinha um bug, o corrigi, e depois encontrei esse bug de novo em outro lugar, e precisei consert√°-lo novamente.

Teve uma vez que peguei um c√≥digo que pegava pesado com essa duplica√ß√£o de c√≥digo, e precisei corrigir um bug em oito lugares diferentes! Pensa em algu√©m irritasdo! Abstrair esse c√≥digo em uma fun√ß√£o para ser chgamada de qualquer lugar, teria ajudado MUITO.

# WET

Aqui outro conceito que a galera chamou de WET(Write Everything Twice, traduzindo "Escreva tudo duas vezes"). Ele √© igualmente dogm√°tico e normativo. [Conlin Durbin](https://twitter.com/CallMeWuz) [a definiu como](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33):

> Voc√™ pode se perguntar "Eu n√£o escrevi isso antes?" duas vezes, mas nunca tr√™s.

In that same codebase I mentioned above, there was some over-abstraction that was even more harmful than duplication. It was AngularJS code and for several AngularJS controllers, the code passed *`this`* to a function which would monkey-patch methods and properties onto *`this`* in a way enhancing the controller instance with certain abilities. A sort of pseudo-inheritance thing I guess. It was SUPER confusing, hard to follow, and I was terrified to make any changes to that area of the codebase.

O c√≥digo foi reutilizado em muito mais que tr√™s lugares, mas a abstra√ß√£o era ruim e desejei que o c√≥digo tivesse sido duplicado.

# AHA

*`AHA`* (pronounced "Aha!" like you just made a discovery) is an acronym I [got from](https://twitter.com/cherthedev/status/1112819136147742720) [Cher Scarlett](https://twitter.com/cherthedev) which stands for

> Avoid Hasty Abstractions

The way I think of this principle is beautifully described by [Sandi Metz](https://twitter.com/sandimetz) who [wrote](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction):

> prefer duplication over the wrong abstraction

This is such a solid golden nugget of wisdom that I want you to read it again, then read Sandi's blog post on the subject: [The Wrong Abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction). It's fantastic.

Here's another important related principle that I want to add:

> Optimize for change first

I think the key is that we don't know what the future of code will be. We could spend weeks optimizing code for performance, or coming up with the best API for our new abstraction, only to find out the next day that we made incorrect assumptions and the API needs a complete rework or the feature the code was written for is no longer needed. We don't know for sure. All we can really be sure of is that things will probably change, and if they never do then we wont touch the code anyway so who cares what it looks like?

Now, don't get me wrong, I'm not suggesting anarchy. I'm just suggesting that we should be mindful of the fact that we don't really know what requirements will be placed upon our code in the future.

So I'm fine with code duplication until you feel pretty confident that you know the use cases for that duplicate code. What parts of the code are different that would make good arguments to your function? After you've got a few places where that code is running, the commonalities will scream at you for abstraction and you'll be in the right frame of mind to provide that abstraction.

If you abstract early though, you'll think the function or component is perfect for your use case and so you just bend the code to fit your new use case. This goes on several times until the abstraction is basically your whole application in *`if`* statements and loops üòÇüò≠

A few years ago, I was hired to review a company's codebase and I used a tool called [jsinspect](https://github.com/danielstjules/jsinspect) to identify chunks of copy/pasted code to show them opportunities for abstraction. They had a bunch of duplicated code and from my perspective looking in, it was obvious what the abstractions should look like.

*I think the big takeaway* about "AHA Programming" is that you shouldn't be dogmatic about when you start writing abstractions but instead write the abstraction when it feels right and don't be afraid to duplicate code until you get there.

# Conclus√£o

Sinto que uma abordagem comedida e pragm√°tica aos princ√≠pios de software √© importante. Por isso eu prefiro *`AHA`* ao inv√©s de *`DRY`* ou *`WET`*. El√° √© focada em te ajudar a ficar ligado em suas abstra√ß√µes, sem fornecer regras r√≠gidas para quando √© ou n√£o certo abstrair algum c√≥digo em uma fun√ß√£o ou m√≥dulo.

Espero que tenha te ajudado. Se voc√™ est√° com abstra√ß√µes ruins at√© o talo, fique de boas. A Sandi tem algumas dicas pra voc√™ de como sair disso! [Basta ler a postagem de seu blog](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction). Boa sorte!
