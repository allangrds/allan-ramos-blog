---
title: React ser√° compilado
subtitle: De certa forma, sempre foi. Mas agora voc√™ pode esquecer a memoiza√ß√£o.
hero_image: "/assets/uploads/cover/programacao_aha.png"
date: 2024-02-22 17:12:00
author: Allan Ramos
category: 'Front-end'
series: ''
tags: ['react']
---

import { TwitterTweetEmbed } from 'react-twitter-embed';

Este artigo √© uma tradu√ß√£o do artigo [React Will Be Compiled](https://reacttraining.com/blog/react-19-will-be-compiled?ref=dailydev) de Brad Westfall.

Ontem, a equipe do React fez uma postagem no blog anunciando no que t√™m trabalhado para o React. Andrew Clark, da equipe do React, nos fornece uma boa an√°lise das mudan√ßas:

<TwitterTweetEmbed tweetId={'1758229889595977824'} />

Corre√ß√£o: Anteriormente, afirmei que seria a vers√£o 19 que seria compilada. O an√∫ncio da equipe do React mencionou o React compilado e eu assumi (assim como outros) que isso se referia √† vers√£o 19. Parece que a vers√£o 19 ter√° muitos recursos mencionados em sua postagem, mas a compila√ß√£o provavelmente ser√° na pr√≥xima vers√£o (como indica Andrew, provavelmente at√© o final deste ano, 2024).

<TwitterTweetEmbed tweetId={'1760433969118769654'} />

Seja qual for a vers√£o, espero que esta postagem ajude qualquer pessoa que se sinta confusa sobre o que significa o React se tornar "compilado". Tentarei mostrar exemplos e contexto hist√≥rico sobre como chegamos a este ponto, pois tem sido um t√≥pico muito discutido e √†s vezes √© dif√≠cil acompanhar, especialmente se voc√™ n√£o viu toda a hist√≥ria do React se desenrolar.

# O React compilado resolver√° os principais problemas dos hooks

Conforme continuamos, mantenha em mente estes princ√≠pios do React que n√£o mudar√£o quando compilarmos o React:

- O estado do React √© imut√°vel.
- A interface do usu√°rio √© uma fun√ß√£o do estado.
- Rerrenderizar quando o estado muda para produzir uma nova interface do usu√°rio.

Al√©m dos n√∫meros de vers√£o, penso no React como tendo tr√™s eras distintas.

- **A era dos componentes de classe** (sem primitivo para abstra√ß√£o)
- **A era dos Hooks** (precisamos memoizar)
- **A era compilada** (auto-memoiza√ß√£o)


Estamos prestes a entrar na era compilada, mas como chegamos at√© aqui?

Para aqueles de n√≥s que criaram projetos com class components, lembramos dos problemas que as classes nos causavam quando quer√≠amos abstrair e reutilizar nosso c√≥digo. O React estava carente de um "primitivo" para reutiliza√ß√£o de c√≥digo, ent√£o a comunidade inventou padr√µes como HOCs (Higher-Order Components) e Render Props, que [eram menos do que ideais](https://gist.github.com/bradwestfall/4fa683c8f4fcd781a38a8d623bec20e7). Acontece que o problema em criar um primitivo era que as pr√≥prias classes n√£o nos forneciam o n√≠vel de composi√ß√£o de que precis√°vamos. Ent√£o, a equipe do React come√ßou a buscar alternativas √†s classes e a se concentrar na composi√ß√£o funcional.

Naquela √©poca, componentes funcionais j√° existiam, mas o cham√°vamos de Stateless Functional Components porque n√£o podiam ter estado ou outros aspectos de ciclo de vida que as classes tinham. A equipe do React viu os componentes funcionais como uma forma de nos dar o primitivo que precis√°vamos. Se ao menos eles pudessem descobrir uma maneira de permitir que os componentes funcionais "se conectassem" aos ciclos de vida do React üòâ

Sim, da√≠ vem o termo "hooks".

Quando os hooks foram anunciados em 2018, eu estava na confer√™ncia. Lembro-me de quando Ryan Florence subiu ao palco para falar logo ap√≥s o an√∫ncio e fez uma refatora√ß√£o de ["render props para hooks" na frente de todos](https://www.youtube.com/watch?v=wXLf18DsV-I). Ficamos impressionados. Hooks, e especificamente hooks personalizados, seriam o primitivo que est√°vamos perdendo.

O que n√£o percebemos na √©poca foi que misturar todo o nosso c√≥digo em uma √∫nica fun√ß√£o poderia nos fornecer composi√ß√£o, mas viria como uma compensa√ß√£o porque agora ter√≠amos que memoizar. N√£o percebemos que as classes naturalmente nos protegiam da memoiza√ß√£o, dada a natureza do rerenderiza√ß√£o.

Nos class components, o m√©todo de renderiza√ß√£o isola seu c√≥digo dos outros [m√©todos do ciclo de vida](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/), o que por sua vez significa que uma rerenderiza√ß√£o n√£o afetar√° adversamente o c√≥digo que n√£o faz parte da fase de renderiza√ß√£o. Isso provavelmente foi menos uma decis√£o de design e mais uma caracter√≠stica de como as classes funcionam. üßê Isso parece quase bobo de mencionar, mas desempenha um papel nas evolu√ß√µes que viriam a seguir.

# React com Memoiza√ß√£o

Para ser honesto, os class components eram terr√≠veis. Lembro-me de quando mudamos nosso curr√≠culo de workshop de dois dias para hooks e metade de nossos t√≥picos simplesmente evaporaram porque os class components introduziam tanta complexidade nas aplica√ß√µes que n√£o precis√°vamos mais ensinar.

Se cri√°ssemos um class component com um m√©todo para lidar com o envio de formul√°rio, o m√©todo nunca precisaria ser "memoizado". Vamos ver o que acontece quando fazemos algo semelhante com componentes funcionais:

```jsx
function App() {
  const [state, setState] = useState()
  function onSubmit() {
    // l√≥gica do evento
  }
  return <form onSubmit={onSubmit}></form>
}
```

Talvez voc√™ n√£o tenha percebido imediatamente, mas esta fun√ß√£o ser√° recriada toda vez que houver uma rerenderiza√ß√£o, o que significa que ser√° uma nova fun√ß√£o na mem√≥ria. Normalmente, n√£o √© um problema que as fun√ß√µes se recriem e, neste exemplo, n√£o est√° causando nenhum problema para n√≥s. Vale ressaltar, no entanto, que isso n√£o aconteceria em classes porque seria um m√©todo separado da fase de renderiza√ß√£o.

Tamb√©m vale ressaltar que a ideia geral de coisas precisarem se recriar em JavaScript n√£o √© espec√≠fica do React. Posso mostrar-lhe meu c√≥digo jQuery de 2008 que tamb√©m recriaria fun√ß√µes e objetos. Estou apenas brincando, n√£o fa√ßo ideia de onde est√° meu c√≥digo de 2008.

Agora vamos refatorar o c√≥digo um pouco:

```jsx
function App() {
  const [state, setState] = useState()
  function onSubmit() {
    // l√≥gica do evento
  }
  return <Form onSubmit={onSubmit} />
}

const Form = ({ onSubmit }) {
  // ...
}
```

Ainda n√£o √© um problema que `onSubmit ser√° uma nova fun√ß√£o em cada renderiza√ß√£o.

A rerrenderiza√ß√£o de `App` causar√° uma rerrenderiza√ß√£o de `Form` neste caso. Alguns dir√£o que um componente receber√° uma rerrenderiza√ß√£o apenas se suas props mudarem. Isso n√£o √© verdade. O `Form` receber√° uma rerenderiza√ß√£o quando o `App` receber uma rerenderiza√ß√£o, independentemente das props. Por enquanto, simplesmente n√£o importa se a propriedade `onSubmit` est√° mudando.

Agora, digamos que tenhamos alguma raz√£o para evitar que `Form` seja rerenderizado quando `App` √© rerenderizado. Este exemplo √© demasiadamente simplista, mas digamos que memoizamos `Form`:

```jsx

// Agora, Form s√≥ ser√° rerenderizado se suas props espec√≠ficas mudarem. N√£o a cada
// vez que App for rerenderizado
const Form = React.memo(({ onSubmit }) => {
  // ...
})
```

Agora temos um problema.


O React depende fortemente de [verifica√ß√µes de igualdade estrita](https://reacttraining.com/blog/state-in-react-is-immutable) para saber se uma vari√°vel mudou, o que √© uma maneira sofisticada de dizer que eles usam `===` e `Object.is()` para comparar o antigo com o novo. Quando voc√™ compara primitivos do JavaScript (como strings) entre si com `===`, o JavaScript os compara pelos valores (voc√™ j√° sabia disso). Mas quando o JavaScript compara arrays, objetos ou fun√ß√µes entre si, o uso de === est√° comparando suas identidades, em outras palavras, sua aloca√ß√£o de mem√≥ria. √â por isso que `{} === {}` √© `false` no JavaScript porque esses s√£o dois identidades de objeto diferentes na mem√≥ria.

Fazer `Form = React.memo(fn)` √© como dizer:

> Ei React, s√≥ queremos rerenderizar Form se suas props realmente mudarem de acordo com uma verifica√ß√£o de identidade.

Isso cria um problema porque `onSubmit` muda toda vez que `App` √© rerenderizado. Isso levar√° a que `Form` seja sempre rerenderizado, o que significa que a memoiza√ß√£o n√£o nos ajuda em nada. √â um sobrecarga sem sentido para o React neste ponto.

Agora, precisamos voltar e garantir que `onSubmit` n√£o mude sua identidade quando App` √© rerenderizado:

```jsx
function App() {
  const [state, setState] = useState()

  const onSubmit = useCallback(() => {
    // l√≥gica do evento
  }, [])

  return <Form onSubmit={onSubmit} />
}
```


N√≥s usamos o `useCallback` para estabilizar a fun√ß√£o para que sua identidade n√£o mude. De certa forma, √© um tipo de memoiza√ß√£o. Em termos excessivamente simplificados, memoiza√ß√£o significa "lembrar" ou "armazenar em cache" a resposta de uma fun√ß√£o.

√â como se estiv√©ssemos dizendo:

> Ei React, lembre-se da identidade desta fun√ß√£o que estou passando para useCallback. Quando tivermos rerenders, estou te dando uma nova fun√ß√£o toda vez, mas esque√ßa isso, me d√™ a identidade da fun√ß√£o original da primeira vez que te chamei.

Memoizar a fun√ß√£o `onSubmit` n√£o √© normalmente necess√°rio, mas se tornou necess√°rio quando `Form` foi memoizado e recebeu `onSubmit como uma propriedade. Na React Training, chamamos isso de "sangramento de implementa√ß√£o"(implementation bleed).

O problema n√£o para por a√≠. Vamos adicionar mais c√≥digo:

```jsx
function App() {
  const [state, setState] = useState()

  const settings = {}
  const onSubmit = useCallback(() => {
    const x = settings.x
    // ...
  }, [])

  // ...
}
```

O objeto `settings`(configura√ß√µes) se recria em cada renderiza√ß√£o de `App`. Isso n√£o √© um problema por si s√≥, mas se voc√™ conhece bem o React, sabe que o linter pedir√° para voc√™ colocar `settings` no array de depend√™ncias do useCallback` neste caso:

```jsx
const settings = {}
const onSubmit = useCallback(() => {
  const x = settings.x
  // ...
}, [settings])
```

Se fizermos isso, √© como se estiv√©ssemos dizendo:

> Queremos que onSubmit seja est√°vel e n√£o mude a cada renderiza√ß√£o. Mas queremos que useCallback recrie onSubmit se qualquer uma das coisas neste array de depend√™ncias mudar.

Voc√™ pode se perguntar: "por que eu gostaria que `onSubmit` mudasse?"

Eu concordo com voc√™, provavelmente n√£o precisa mudar, mas h√° muitas situa√ß√µes no React em que coisas como `useCallback` e `useMemo` precisam re-memoizar e criar uma nova identidade para seu valor de retorno quando seu array de depend√™ncias muda. O linter simplesmente n√£o sabe que nunca queremos que `onSubmit` seja diferente neste caso.

Lembre-se de que o linter est√° quase sempre certo, mas escolhi este exemplo para mostrar como podemos n√£o querer o que o linter quer.

Se ouvirmos o linter e colocarmos `settings` no array de depend√™ncias, aqui est√° o que acontecer√°:


- Quando `App` √© rerenderizado...
- `settings` se torna um novo objeto que n√£o √© `===` ao que estava na renderiza√ß√£o anterior.
- O array de depend√™ncias v√™ `settings` como diferente de acordo com `===` mesmo que seus valores n√£o tenham mudado.
- A mudan√ßa no array de depend√™ncias significa que `useCallback` retorna uma nova identidade para onSubmit.
- O `Form` √© rerenderizado porque `onSubmit` muda.

Em resumo, a memoiza√ß√£o de `Form` √© in√∫til. Ele sempre ser√° rerenderizado quando `App` for rerenderizado. Ent√£o agora temos mais "sangramento de implementa√ß√£o"(implementation bleed) porque precisamos memoizar `settings` com `useMemo` apenas para que possamos manter a memoiza√ß√£o de `onSubmit` intacta.

Vamos dar um passo atr√°s para aquela pergunta:

> Por que eu gostaria que onSubmit mudasse? N√£o poder√≠amos simplesmente desativar o linter nesse caso?

Claro, neste caso, acho que podemos deixar `settings` fora do array de depend√™ncias ou podemos simplesmente memoiz√°-lo, que √© o que eu provavelmente faria. Ou at√© mesmo poder√≠amos argumentar que n√£o precis√°vamos do formul√°rio memoizado em primeiro lugar, o que teria evitado essa bagun√ßa. Isso n√£o √© o ponto, √© apenas um exemplo. O ponto √© que a memoiza√ß√£o no React frequentemente leva a um cascata de "sangramento de implementa√ß√£o"(implementation bleed).

O t√≥pico dos arrays de depend√™ncia e por que o linter quer que voc√™ coloque coisas neles vai muito al√©m do escopo deste post. Eu provavelmente poderia falar sobre esse t√≥pico por horas porque √© vasto, com muitos detalhes. A verdade √© que o linter geralmente est√° certo e tem boas inten√ß√µes. O problema √© que MUITOS desenvolvedores do React n√£o entendem seu racioc√≠nio e acham que o linter √© apenas uma pequena sugest√£o. Na minha experi√™ncia, quando voc√™ ignora o linter, provavelmente encontrar√° bugs.

Aqui est√° um exemplo perfeito: Alguns anos atr√°s, estava conversando com algu√©m no Twitter que disse que nunca colocava fun√ß√µes no array de depend√™ncias de seu `useEffect` porque √†s vezes criava um loop infinito. Eu disse algo como "por que voc√™ n√£o usa `useCallback` nessas fun√ß√µes, isso evitar√° o loop. O problema √© que a fun√ß√£o est√° mudando com muita frequ√™ncia".

Eles disseram "O que √© useCallback?"

√â comum as pessoas n√£o entenderem memoiza√ß√£o ou React o suficiente e depois ficarem frustradas com o linter.

# Dependente de memoiza√ß√£o

Se voc√™ trabalhou o suficiente com React, sabe que pode ser um inc√¥modo lidar com os arrays de depend√™ncias. O linter pode lhe dizer para colocar coisas no array e voc√™ n√£o gosta do resultado (como um loop). √â f√°cil ficar irritado com o linter, mas o linter estava certo. N√£o porque o React "quer" um loop infinito, √© claro, mas porque voc√™ precisava tamb√©m memoizar algo agora.

Os arrays de depend√™ncia s√£o uma forma de lidar com o fato de que todo o nosso c√≥digo est√° co-localizado em um componente funcional que rerenderiza, e queremos monitorar as mudan√ßas nas vari√°veis ao longo do tempo. √Äs vezes, acabamos colocando objetos, arrays e fun√ß√µes no array de depend√™ncias, ent√£o certifique-se de estabiliz√°-los com memoiza√ß√£o. A maneira como explico o que o React significa por "est√°vel" √© "uma vari√°vel que n√£o muda a menos que voc√™ queira".

Vamos demonstrar isso com c√≥digo:

```jsx
function App() {
  const [misc, setMisc] = useState()
  const [darkMode, setDarkMode] = useState(false)
  const options = { darkMode }

  return <User options={options} />
}

function User({ options }) {
  useEffect(() => {
    // get user
  }, [options])

  // ...
}
```

Podemos ver que quando o estado misc em `App` muda, a consequ√™ncia em cascata √© que `options` mudar√° e, portanto, o `useEffect` ser√° executado novamente, mesmo que o efeito n√£o tenha nada a ver com o estado `misc`. Portanto, √© melhor envolver a vari√°vel `options` em um `useMemo`. Quando voc√™ fizer isso, o linter pedir√° corretamente para voc√™ colocar `darkMode no array de depend√™ncias:

```jsx
const [darkMode, setDarkMode] = useState(false)
const options = useMemo(() => {
  return { darkMode }
}, [darkMode])
```

Ao fazer isso, estamos dizendo:

> Queremos que options seja est√°vel, at√© que o modo escuro mude. Em seguida, reestabilize-o em uma nova identidade. Mas n√£o fa√ßa nada quando o estado misc mudar, porque n√£o est√° em nosso array (n√£o dependemos dele).

Sim, entendi o ponto. No React, a memoiza√ß√£o √© fundamental e √© responsabilidade do desenvolvedor implement√°-la corretamente. Caso contr√°rio, podem ocorrer bugs e problemas de desempenho. √â importante entender como e quando aplicar a memoiza√ß√£o para garantir um c√≥digo eficiente e livre de erros.


# Sempre compilamos o React

Dependendo da sua defini√ß√£o do termo, voc√™ poderia argumentar que o React sempre teve uma etapa de compila√ß√£o (JSX). Para mim, parece ser um termo solto no JavaScript que basicamente significa que o c√≥digo que voc√™ escreve √© diferente do c√≥digo que √© executado no navegador.

Minha primeira experi√™ncia com o React foi em 2015. Babel e React ainda eram relativamente novos para a maioria dos desenvolvedores. De certa forma, sua popularidade cresceu em conjunto. O React √© famosamente conhecido por compilar JSX em chamadas de fun√ß√£o. Ent√£o, eu acho que o React √© tecnicamente compilado, mas sempre senti que era um pequeno syntax sugar e que a sem√¢ntica de um elemento JSX se tornando uma fun√ß√£o muito previs√≠vel significa para mim que √© uma quantidade de compila√ß√£o relativamente "leve".

Hoje em dia, tamb√©m compilamos TypeScript para JavaScript, o que para mim √© engra√ßado, porque neste caso significa apenas que todo o TypeScript que escrevemos evapora quando salvamos e o c√≥digo que resta √© o JavaScript. Mas eu acho que ainda se encaixa na minha defini√ß√£o de "o que voc√™ escreve √© o que voc√™ obt√©m".

# Compilar √© um espectro

Para mim, parece que "frameworks compilados" se situam em um espectro onde alguns s√£o compilados um pouco e outros s√£o compilados bastante:

![Espectro da compila√ß√£o e vers√µes do react](/assets/uploads/posts/react-compilado/react-versoes.png)

O React parece estar mais no lado "n√£o muito" em compara√ß√£o com alguns outros frameworks JavaScript modernos. Para mim, a regra do "o que voc√™ v√™ √© o que voc√™ obt√©m" determinar√° onde voc√™ est√° neste espectro. O JSX significa que o React √© um pouco compilado, mas o outro c√≥digo que escrevo n√£o √© compilado pelo React.

Por outro lado, o Svelte √© t√£o fortemente compilado que seu criador o [descreveu como nem mesmo sendo JavaScript](https://gist.github.com/Rich-Harris/0f910048478c2a6505d1c32185b61934). O Svelte √© realmente mais uma linguagem de programa√ß√£o porque a sem√¢ntica do que voc√™ escreve est√° t√£o longe da sem√¢ntica do que voc√™ obt√©m quando ele se transforma em JavaScript.

N√£o estou tentando tornar este um post de compara√ß√£o, ou dizer que um caminho √© melhor que o outro, ou que compilar √© bom ou ruim. Estou simplesmente dizendo que parece ser um espectro onde diferentes frameworks JavaScript compilam menos, ou compilam mais, ou compilam at√© o ponto em que nem mesmo s√£o realmente JS mais.

O an√∫ncio da equipe do React √© que o React vai ser mais compilado do que era antes. Ser√° mais do que alguns dos outros? N√£o tenho certeza. N√£o importa muito onde ele acaba neste espectro para mim. O que importa mais √© por que ele est√° sendo compilado. A resposta √© por raz√µes diferentes das dos outros.

# Compilando para Auto-Memoiza√ß√£o

O React n√£o est√° abandonando a imutabilidade e indo em rumo para a observabilidade. Ainda ter√° verifica√ß√µes de identidade e arrays de depend√™ncia. Ent√£o, o fato de estar compilado agora n√£o faz o React parecer semelhante aos outros. Ele ser√° compilado para que possamos ter auto-memoiza√ß√£o. O React √© o mesmo de sempre, mas sem as desvantagens da memoiza√ß√£o manual, que era um dos principais problemas com hooks e componentes funcionais.

Pessoalmente, estou acostumado com minha l√≥gica acima do JSX ser deixada intocada. Essa mudan√ßa ser√° principalmente desaprender a pensar em termos de memoiza√ß√£o manual. Terei que confiar no compilador para tomar boas decis√µes para mim e ainda estou incerto sobre quanto disso terei que orientar o compilador vs "It Just Works‚Ñ¢". Estou otimista e interessado em experimentar.

Em resumo, vale ressaltar que essa ideia n√£o surgiu do nada. Estamos discutindo isso como uma possibilidade no React h√° tr√™s anos, desde que [Xuan Huang introduziu a ideia na React Conf 2021](https://www.youtube.com/watch?v=lGEMwh32soc). Tamb√©m houve momentos em que foi o t√≥pico quente no Twitter nos c√≠rculos do React h√° alguns anos.

Minha esperan√ßa √© que, se voc√™ n√£o estava ciente dessas conversas, este post forne√ßa exemplos e contexto justos sobre como chegamos a este ponto. Obrigado por ler!
